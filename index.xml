<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kunal Kushwaha&#39;s Blog</title>
    <link>http://kunalkushwaha.github.io/</link>
    <description>Recent content on Kunal Kushwaha&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>This work is licensed under a Creative Commons Attribution-ShareAlike 4.0 International (CC BY-SA 4.0) License. Some rights reserved by James R. Cogley</copyright>
    <lastBuildDate>Sat, 04 Jul 2015 20:25:44 +0900</lastBuildDate>
    <atom:link href="http://kunalkushwaha.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Container Virtualization and its building blocks</title>
      <link>http://kunalkushwaha.github.io/post/container-virtualization-and-its-building-blocks</link>
      <pubDate>Sat, 04 Jul 2015 20:25:44 +0900</pubDate>
      
      <guid>http://kunalkushwaha.github.io/post/container-virtualization-and-its-building-blocks</guid>
      <description>

&lt;p&gt;Since 2014, Linux containers have become buzz word in Cloud Infrastructure. Almost all, from Big corporations to startups, all have started using it. Huge credit goes to &lt;a href=&#34;www.docker.com&#34;&gt;Docker&lt;/a&gt; for making using containers so easy to use.&lt;/p&gt;

&lt;p&gt;Linux Containers are there in Linux systems for alomst decade old, But making them work, was not so easy, and generally required linux admin experts for doing same. Few Solution as linux containers like FreeBSD Jails, LXC, openVZ, Solaris Zones etc exists for quite some time.&lt;/p&gt;

&lt;p&gt;These are also known as OS level Virtualization.
To understand other type of virtualization please read &lt;a href=&#34;http://kunalkushwaha.github.io/post/Layman-guide-to-Platform-Virtualization&#34;&gt;Layman guide to Platform virtualization&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;operating-system-level-virtualization:b9f02760c1e2afe4297fc7674428ef9f&#34;&gt;Operating System level Virtualization&lt;/h2&gt;

&lt;p&gt;Quoting below from Wikipedia, I it explains beautifully in technical and yet not too complex.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;OS level Virtualization is a server virtualization method where the kernel of an operating system allows for multiple isolated user space instances, instead of just one. Such instances (often called containers, virtualization engines (VE), virtual private servers (VPS), or jails) may look and feel like a real server from the point of view of its owners and users.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In simple words, it allows to run multiple rootfs (user-space) simultaneously and all running rootfs have their own view of filesystem and devices. So they are not aware of each others and resource usage can be configured.&lt;/p&gt;

&lt;p&gt;Sounds similar to virtual Machines? Yes it is!&lt;/p&gt;

&lt;h4 id=&#34;how-this-isolation-is-achieved:b9f02760c1e2afe4297fc7674428ef9f&#34;&gt;How this isolation is achieved?&lt;/h4&gt;

&lt;p&gt;This isolation is achieved using linux features like namespaces, cgroups and chroot. To understand details we need to first understand each of them.&lt;/p&gt;

&lt;h4 id=&#34;namespaces:b9f02760c1e2afe4297fc7674428ef9f&#34;&gt;Namespaces&lt;/h4&gt;

&lt;p&gt;Namespace wraps a particular global system resource in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource.&lt;/p&gt;

&lt;p&gt;Currently, Linux implements six different types of namespaces&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;h5 id=&#34;mount-namespaces-clone-newns:b9f02760c1e2afe4297fc7674428ef9f&#34;&gt;Mount namespaces (CLONE_NEWNS)&lt;/h5&gt;

&lt;p&gt;This isolate the set of filesystem mount points seen by a group of processes. Thus, processes in different mount namespaces can have different views of the filesystem hierarchy. With the addition of mount namespaces, the mount() and umount() system calls ceased operating on a global set of mount points visible to all processes on the system and instead performed operations that affected just the mount namespace associated with the calling process.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This is also an alternative to chroot system call.&lt;/li&gt;
&lt;li&gt;This is supported since Linux 2.4.19&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;h5 id=&#34;uts-namespaces-clone-newuts:b9f02760c1e2afe4297fc7674428ef9f&#34;&gt;UTS namespaces (CLONE_NEWUTS)&lt;/h5&gt;

&lt;p&gt;This isolate two system identifiers—nodename and domainname—returned by the uname() system call; the names are set using the sethostname() and setdomainname() system calls.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In the context of containers, the UTS namespaces feature allows each container to have its own hostname and NIS domain name. This can be useful for initialization and configuration scripts that tailor their actions based on these names.&lt;/li&gt;
&lt;li&gt;This is supported in Linux kernel since  Linux 2.6.19.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;h5 id=&#34;ipc-namespaces-clone-newipc:b9f02760c1e2afe4297fc7674428ef9f&#34;&gt;IPC namespaces (CLONE_NEWIPC)&lt;/h5&gt;

&lt;p&gt;This isolate certain interprocess communication (IPC) resources, namely, System V IPC objects and (since Linux 2.6.30) POSIX message queues.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The common characteristic of these IPC mechanisms is that IPC objects are identified by mechanisms other than filesystem pathnames. Each IPC namespace has its own set of System V IPC identifiers and its own POSIX message queue filesystem.&lt;/li&gt;
&lt;li&gt;This is supported in Linux kernel since Linux 2.6.19&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;h5 id=&#34;pid-namespaces-clone-newpid:b9f02760c1e2afe4297fc7674428ef9f&#34;&gt;PID namespaces (CLONE_NEWPID)&lt;/h5&gt;

&lt;p&gt;This isolate the process ID number space. In other words, processes in different PID namespaces can have the same PID.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;This helps migrating containers between hosts while keeping the same process IDs for the processes inside the container.&lt;/li&gt;
&lt;li&gt;PID namespaces also allow each container to have its own init (PID 1), the &amp;ldquo;ancestor of all processes&amp;rdquo; that manages various system initialization tasks and reaps orphaned child processes when they terminate.&lt;/li&gt;
&lt;li&gt;This is supported since Linux 2.6.24&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;h5 id=&#34;network-namespaces-clone-newnet:b9f02760c1e2afe4297fc7674428ef9f&#34;&gt;Network namespaces (CLONE_NEWNET)&lt;/h5&gt;

&lt;p&gt;This provide isolation of the system resources associated with networking. Thus, each network namespace has its own network devices, IP addresses, IP routing tables, /proc/net directory, port numbers, and so on.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Network namespaces make containers useful from a networking perspective: each container can have its own (virtual) network device and its own applications that bind to the per-namespace port number space.&lt;/li&gt;
&lt;li&gt;started in Linux 2.4.19 2.6.24 and largely completed by about Linux 2.6.29&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;h5 id=&#34;user-namespaces-clone-newuser:b9f02760c1e2afe4297fc7674428ef9f&#34;&gt;User namespaces (CLONE_NEWUSER)&lt;/h5&gt;

&lt;p&gt;This isolate the user and group ID number spaces. In other words, a process&amp;rsquo;s user and group IDs can be different inside and outside a user namespace.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The most interesting case here is that a process can have a normal unprivileged user ID outside a user namespace while at the same time having a user ID of 0 inside the namespace. This means that the process has full root privileges for operations inside the user namespace, but is unprivileged for operations outside the namespace.&lt;/li&gt;
&lt;li&gt;This was partially supported since Linux 2.6.23 and completed in Linux 3.8.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;control-groups-a-k-a-cgroups:b9f02760c1e2afe4297fc7674428ef9f&#34;&gt;Control groups a.k.a. cgroups&lt;/h4&gt;

&lt;p&gt;Cgroups allow you to allocate resources—such as CPU time, system memory, network bandwidth, or combinations of these resources—among user-defined groups of tasks (processes) running on a system.
  - One can configure cgroups, deny cgroups access to certain resources, and even reconfigure cgroups dynamically on a running system.
  - The cgconfig (control group config) service can be configured to start up at boot time and reestablish your predefined cgroups, thus making them persistent across reboots.
  - By using cgroups, we gain fine-grained control over allocating, prioritizing, denying, managing, and monitoring system resources. Hardware resources can be appropriately divided up among tasks and users, increasing overall efficiency.
  - These are like process, hierarchical in nature i.e. child cgroups inherit certain attributes from their parent cgroup.&lt;/p&gt;

&lt;p&gt;Follwing resources are supported currently in cgroups.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;blkio — this subsystem sets limits on input/output access to and from block devices such as physical drives (disk, solid state, USB, etc.).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpu — this subsystem uses the scheduler to provide cgroup tasks access to the CPU.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpuacct — this subsystem generates automatic reports on CPU resources used by tasks in a cgroup.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;cpuset — this subsystem assigns individual CPUs (on a multicore system) and memory nodes to tasks in a cgroup.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;devices — this subsystem allows or denies access to devices by tasks in a cgroup.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;freezer — this subsystem suspends or resumes tasks in a cgroup.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;memory — this subsystem sets limits on memory use by tasks in a cgroup, and generates automatic reports on memory resources used by those tasks.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;net_cls — this subsystem tags network packets with a class identifier (classid) that allows the Linux traffic controller (tc) to identify packets originating from a particular cgroup task.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;net_prio — this subsystem provides a way to dynamically set the priority of network traffic per network interface.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ns — the namespace subsystem.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For details you may refer : &lt;a href=&#34;https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt&#34;&gt;https://www.kernel.org/doc/Documentation/cgroups/cgroups.txt&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;so-how-these-helps-in-containers:b9f02760c1e2afe4297fc7674428ef9f&#34;&gt;So how these helps in containers?&lt;/h2&gt;

&lt;p&gt;By now, you must have understood, namespaces and cgroups help to create isolated environment.
- Namespaces provides isolation of filesystem view, devices, network and processes.
- Cgroups helps to allocate, devices accessibility, and allocate quota to use the devices.&lt;/p&gt;

&lt;p&gt;&lt;img align=&#34;center&#34; src=http://kunalkushwaha.github.io/images/containers.png&gt;&lt;/p&gt;

&lt;h2 id=&#34;is-this-all-sufficient-for-virtualization:b9f02760c1e2afe4297fc7674428ef9f&#34;&gt;Is this all sufficient for Virtualization?&lt;/h2&gt;

&lt;p&gt;No, still security is left. To create secure containers features like Capablities, secomp , SELinux and Apparmor are used for that. These all are integrated with new container solutions like Docker, CoreOS rocket etc.&lt;/p&gt;

&lt;p&gt;Few Container projects worth wating are
- LXC - Linux containers : This is default container hypervisior on all linux based systems. &lt;a href=&#34;https://linuxcontainers.org/&#34;&gt;https://linuxcontainers.org/&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Docker libcontainer:
This is now donated by Docker to Linux foundation and new name will is OpenContainers. &lt;a href=&#34;http://www.opencontainers.org/&#34;&gt;http://www.opencontainers.org/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;CoreOS - Rocket - &lt;a href=&#34;https://github.com/coreos/rkt&#34;&gt;https://github.com/coreos/rkt&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Redhat&amp;rsquo;s systemd-nspawn. &lt;a href=&#34;http://www.freedesktop.org/software/systemd/man/systemd-nspawn.html&#34;&gt;http://www.freedesktop.org/software/systemd/man/systemd-nspawn.html&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I hope this blog would have help you to understand Linux Containers.&lt;/p&gt;

&lt;p&gt;I will be writing more on current status of linux containers projects in my next blog so stay tuned :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Golang Development Environment</title>
      <link>http://kunalkushwaha.github.io/post/golang-development-environment</link>
      <pubDate>Mon, 27 Apr 2015 22:29:36 +0900</pubDate>
      
      <guid>http://kunalkushwaha.github.io/post/golang-development-environment</guid>
      <description>

&lt;p&gt;Setting up golang environment is quite simple good docs are already present in golang.org.
&lt;br&gt;But I couldn&amp;rsquo;t find any simple doc, where complete setup with GOROOT and GOPATH along with github is explained.&lt;/p&gt;

&lt;p&gt;So I thought it might be helpful to others too.
&lt;br&gt;My dev environment is ubuntu based &lt;a href=&#34;https://elementary.io/&#34;&gt;ElementryOS &amp;ldquo;Freya&amp;rdquo;&lt;/a&gt;, So it would work on all Ubuntu based distros.&lt;/p&gt;

&lt;h3 id=&#34;golang-installer:22b90498ad19ed8bfadbfc3c440b6be8&#34;&gt;Golang Installer&lt;/h3&gt;

&lt;p&gt;Golang comes with single tar file setup can be downloaded from &lt;a href=&#34;https://golang.org/dl/&#34;&gt;here&lt;/a&gt;
&lt;br&gt;extract the tar file to your /usr/local using below command&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;tar -C /usr/local -xzf go$VERSION.$OS-$ARCH.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;this will install your all go binaries under following dir structure.&lt;/p&gt;

&lt;p&gt;base folder where go is installed.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/usr/local/go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All standard go binaries are in&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;/usr/local/go/bin 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;golang-environment-setup:22b90498ad19ed8bfadbfc3c440b6be8&#34;&gt;Golang environment setup.&lt;/h3&gt;

&lt;p&gt;Now next step is to define golang related environment variable.
&lt;br&gt;There are two important golang Env variables that need to be defined.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;GOROOT : This variable have value, where golang is installed.&lt;/li&gt;
&lt;li&gt;GOPATH : This is like workspace. This folder will be root of all go getable packages and projects.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br&gt;So you need to create a folder for GOPATH. My fav is ~/go folder.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kunal@kunal-Aspire-5670:~$ mkdir ~/go
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So now define GOROOT, GOPATH and append PATH variables.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;export GOROOT=/usr/local/go
export GOPATH=$HOME/go
export PATH=$PATH:$GOROOT/bin:$GOPATH/bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Its better to append your ~/.profile file with these 3 lines. So no need to export these variables every time you restart machine.&lt;/p&gt;

&lt;p&gt;After setting environment variables check if everything is set as per expected or not!
&lt;br&gt;Use &amp;ldquo;go env&amp;rdquo; command.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kunal@kunal-Aspire-5670:~$ go env
GOARCH=&amp;quot;386&amp;quot;
GOBIN=&amp;quot;&amp;quot;
GOCHAR=&amp;quot;8&amp;quot;
GOEXE=&amp;quot;&amp;quot;
GOHOSTARCH=&amp;quot;386&amp;quot;
GOHOSTOS=&amp;quot;linux&amp;quot;
GOOS=&amp;quot;linux&amp;quot;
GOPATH=&amp;quot;/home/kunal/go&amp;quot;
GORACE=&amp;quot;&amp;quot;
GOROOT=&amp;quot;/usr/local/go&amp;quot;
GOTOOLDIR=&amp;quot;/usr/local/go/pkg/tool/linux_386&amp;quot;
CC=&amp;quot;gcc&amp;quot;
GOGCCFLAGS=&amp;quot;-fPIC -m32 -pthread -fmessage-length=0&amp;quot;
CXX=&amp;quot;g++&amp;quot;
CGO_ENABLED=&amp;quot;1&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;verify GOPATH and GOROOT.&lt;/p&gt;

&lt;h3 id=&#34;go-getable:22b90498ad19ed8bfadbfc3c440b6be8&#34;&gt;go getable.&lt;/h3&gt;

&lt;p&gt;One of beauty of golang is &amp;ldquo;go get&amp;rdquo; command.
&lt;br&gt;It automatically downloads the all required packages along with your program from git repo or mercurial.&lt;/p&gt;

&lt;p&gt;Prerequisite to this is you should install git and mercurial both on your machine.
mercurial is required as lot of official libraries of golang is still hosted at google code and it hosted with mercurial.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kunal@kunal-Aspire-5670:~$ sudo apt-get install mercurial
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we are set with all basics, now ready for go getable your code!&lt;/p&gt;

&lt;p&gt;after your go get github.com/&lt;some-go-project&gt;, You will see your ~/go folder have sum folder structure created.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kunal@kunal-Aspire-5670:~$ ll go
total 32
drwxrwxr-x  6 kunal kunal  4096 Apr 20 20:28 ./
drwx------ 24 kunal kunal 12288 Apr 27 22:45 ../
drwxrwxr-x  2 kunal kunal  4096 Apr 16 03:27 bin/
drwxrwxr-x  3 kunal kunal  4096 Apr 12 21:26 pkg/
drwxrwxr-x  8 kunal kunal  4096 Apr 16 03:24 src/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are folder which will have all your go getable code/packages and binaries.
*bin : folder will have binaries build after you build go project using &amp;ldquo;go build&amp;rdquo;
*pkg : this will have all pakages downloaded due to dependencies of your program. These packages compiled packages.
*src : this will have your source code under folder of source of code like github.com , bitbucket.com, code.google.com etc
e.g&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-shell&#34;&gt;kunal@kunal-Aspire-5670:~$ ll go/src/
total 32
drwxrwxr-x  8 kunal kunal 4096 Apr 16 03:24 ./
drwxrwxr-x  6 kunal kunal 4096 Apr 20 20:28 ../
drwxrwxr-x  3 kunal kunal 4096 Apr 16 03:24 bitbucket.org/
drwxrwxr-x  3 kunal kunal 4096 Apr 12 21:28 code.google.com/
drwxrwxr-x 38 kunal kunal 4096 Apr 20 20:05 github.com/
drwxrwxr-x  3 kunal kunal 4096 Apr 12 21:29 golang.org/
drwxrwxr-x  3 kunal kunal 4096 Apr 12 21:29 google.golang.org/
drwxrwxr-x  6 kunal kunal 4096 Apr 16 03:26 gopkg.in/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So you are now all set for code/test/ship in golang. Happy Coding :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Layman guide to Platform Virtualization</title>
      <link>http://kunalkushwaha.github.io/post/layman-guide-to-platform-virtualization</link>
      <pubDate>Sat, 25 Apr 2015 23:20:04 +0900</pubDate>
      
      <guid>http://kunalkushwaha.github.io/post/layman-guide-to-platform-virtualization</guid>
      <description>

&lt;p&gt;&lt;img align=&#34;center&#34; src=http://kunalkushwaha.github.io/VirtualMachineCartoon.jpg&gt;&lt;/p&gt;

&lt;h3 id=&#34;platform-virtualization:a88864bb2e02cbfffb44963e73e3622a&#34;&gt;Platform Virtualization!&lt;/h3&gt;

&lt;p&gt;Virtualization is not new in Computer World today.
But when I am asked what I am working on, I say &amp;ldquo;Cloud Infrastructure and trying to build a private Cloud Platform!&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Explaining cloud service is easy but Cloud Infrastructure becomes little difficult.
So I am writing a blog series to explain Cloud Infrastructure and it building blocks.
Hope it will help many others too :)&lt;/p&gt;

&lt;h3 id=&#34;virtualization:a88864bb2e02cbfffb44963e73e3622a&#34;&gt;Virtualization.&lt;/h3&gt;

&lt;p&gt;Though simple meaning of Virtualization is creating virtual version of anything.
But in computer software world everything is already Virtual :).
But computer hardware devices, Network cable etc are real!&lt;/p&gt;

&lt;p&gt;When all these things are created virtually i.e. software simulation of all such hardware its called virtualization!&lt;/p&gt;

&lt;p&gt;But why that is required? I heard Hardware is becoming cheap day by day :-|
These are genuine doubts! indeed hardware is becoming cheap and also performance of capacity wise is improving at much faster rate then ever.&lt;/p&gt;

&lt;p&gt;Also, with increase of hardware capacity, most of hardware are underutilized :O
Yes and this becomes huge concern for business owner, How to utilize best of your hardware.
Second Management of hardware resources is also a addition of cost.&lt;/p&gt;

&lt;p&gt;Using Virtualization both issues can be addressed.
Multiple systems workload is executed on same hardware which result into better utilization,
and Managing multiple systems with software also makes more efficient and easy.&lt;/p&gt;

&lt;h3 id=&#34;how-is-virtualization-is-achieved:a88864bb2e02cbfffb44963e73e3622a&#34;&gt;How is Virtualization is achieved?&lt;/h3&gt;

&lt;p&gt;There are broadly three types of Virtualization Techniques.
&lt;a href=&#34;http://en.wikipedia.org/wiki/Virtualization#Hardware_virtualization&#34;&gt;Wikipedia&lt;/a&gt; has short and crisp definition for all three.&lt;/p&gt;

&lt;p&gt;Here Host OS is the OS which runs on Actual Hardware and Guest OS is running on Virtual Hardware/Machine.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Full virtualization – almost complete simulation of the actual hardware to allow software, which typically consists of a guest operating system, to run unmodified.
&lt;br&gt;e.g. VirtualBox, VMWare Workstations, Parallel for MAC works on full virtualization, No change is required in guest OS&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Partial virtualization – some but not all of the target environment attributes are simulated. As a result, some guest programs may need modifications to run in such virtual environments.
&lt;br&gt;Probably this is first approach to virtualization which lead to full virtualization.
&lt;br&gt;e.g. IBM mainfraim system &lt;a href=&#34;http://en.wikipedia.org/wiki/IBM_M44/44X&#34;&gt;IBM M44/44X&lt;/a&gt; was one of such experimental machine.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Paravirtualization – a hardware environment is not simulated; however, the guest programs are executed in their own isolated domains, as if they are running on a separate system. Guest programs need to be specifically modified to run in this environment.
&lt;br&gt;Paravirtulization is lightweight as compared to full virtualization.
&lt;br&gt;e.g. XEN is based on paravirtualization.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;so-what-we-understood:a88864bb2e02cbfffb44963e73e3622a&#34;&gt;So what we understood!&lt;/h3&gt;

&lt;p&gt;Well, We must have realized with all these techniques, all that is achieved here is Isolation!
Isolation of Hardware, so OS running in Virtual Machine gets a feel all hardware is available for its use.
That is the way all OS are implemented! Exclusive access to hardware.&lt;/p&gt;

&lt;p&gt;But above three methods are not that efficient with Hardware support for Virtualization.
So, CPU also have extra core and support to run the Virtualization code efficently. More you can find on &lt;a href=&#34;http://en.wikipedia.org/wiki/X86_virtualization&#34;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Since Isolation is the key to virtulization, Unix &amp;amp; Linux based OS have few features, which provides Isolation to process.
Features like namespaces, cgroups and chroot.
Utilzing these features, OS level virtualization can be achieved. In linux these are called Containers.&lt;/p&gt;

&lt;p&gt;I will be writing details of containers in my next blog. So stay tuned :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Moving to Hugo &amp; github</title>
      <link>http://kunalkushwaha.github.io/post/moving-to-hugo--github</link>
      <pubDate>Wed, 04 Mar 2015 14:53:05 +0530</pubDate>
      
      <guid>http://kunalkushwaha.github.io/post/moving-to-hugo--github</guid>
      <description>

&lt;p&gt;Started blogging today after few years of gap. Had stopped blogging few years back on &lt;a href=&#34;http://kunalkushwaha.wordpress.com&#34;&gt;wordpress&lt;/a&gt; .&lt;/p&gt;

&lt;p&gt;Blogging is always fun and great way to share your experiences and findings with others.&lt;/p&gt;

&lt;p&gt;Lot of things have changed in last 3-5 years in world of Web Technology, So is the blogging platform too.
While exploring Web Technologies and Golang, I came across the static site genrator and Hugo.&lt;/p&gt;

&lt;p&gt;I found it really powerful tool for blogging as well as Product Documentations.&lt;/p&gt;

&lt;h2 id=&#34;why-not-to-continue-with-wordpress:1dd8e767a925214d802c5a963c76c86a&#34;&gt;Why not to continue with wordpress!&lt;/h2&gt;

&lt;p&gt;I work most of times on linux terminal and &lt;a href=&#34;http://gohugo.io/&#34;&gt;Hugo&lt;/a&gt; with github is seamlessly integrated with  git workflow.
Also, I have complete control over theme and customization. This learning is helpful to me for product documentation too :)&lt;/p&gt;

&lt;p&gt;Going ahead I am hopeful, will write regularly and share intresting findings from work and side projects.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>http://kunalkushwaha.github.io/about/</link>
      <pubDate>Tue, 03 Mar 2015 17:59:00 +0530</pubDate>
      
      <guid>http://kunalkushwaha.github.io/about/</guid>
      <description>&lt;p&gt;Hi this is Kunal&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>